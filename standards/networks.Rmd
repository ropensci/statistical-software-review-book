<!-- Edit the .Rmd not the .md file -->

```{r requires, echo = FALSE, message = FALSE}
library (igraph)
```


## Network Software {#standards-networks}

### Documentation

Network software is frequently developed for domain-specific use-cases, such as
for genomic data, or social networks. Even when software is intended to enable
truly general use, the following standard applies.

- **NW1.0** *Network software should explicitly indicate its domain of
  applicability, generally as a broad description of applicable academic (or
  equivalent) domains.*

Authors are encouraged to include as many *potentially* applicable or relevant
domains as possible, even if application in such domains has been neither tried
nor demonstrated. Authorial statements of potential applicability are one of
the clearest ways to encourage usage of software beyond the initial domains for
which it might have been developed.

- **NW1.1** *Network software should document scaling relationships between
  sizes of input data (numbers of vertices, edges, or both) and algorithmic speed,
  and describe the expected range of data size for which the software is usable.*

This documentation may be placed anywhere, including in a dedicated vignette,
but should at least be referenced from a primary location such as the main
README file.


### Input Data Structures and Validation

Most network software is intended to accept networks as input parameters. This
is nevertheless not always the case, and many of the following standards may
not apply to software which transforms non-network inputs into internal network
representations. The following two sub-sections will generally be mutually
exclusive, and software will either accept class-based inputs, and so comply
with the standards in the following sub-section, or it will accept generic
inputs, and so comply with the standards in the sub-section after that.

#### Class-based inputs

R has a number of widely used packages for representing and analysing networks.
The following standard reflects one aim of rOpenSci to curate an interoperable
"ecosystem" of software:

- **NW2.0** *Where possible or practicable, network software should either represent
  network data using a common representation, or at least prominently
  demonstrate how to convert package-internal representations to common forms.*

"Common representations" refer to the types offered by widely-used packages for
network representation and/or analyses, including but not limited to the
packages [`igraph`](https://igraph.org),
[`tidygraph`](https://tidygraph.data-imaginist.com/),
[`network`](https://github.com/statnet/network), or
[`sfNetworks`](https://luukvdmeer.github.io/sfnetworks/) for spatial networks.

- **NW2.1** *Network software which accepts networks as inputs should
  explicitly indicate the expected forms of those networks.*

- **NW2.2** *Submitting inputs in any common class beyond those accepted by
  network software should result in error messages providing helpful
  information on how to convert to appropriate classes.*


#### Generic input structures

Network software may accept generic inputs which do not rely on specific class
structures. Network representations may be edge-based, "standard" graph-based
representations, or matrix-based. The following standards apply to generic
input structures.

- **NW2.3** *Network software which accepts generic input structures (such as
  matrices) should implement initial validation routines to ensure the internal
  properties of input data confirm with expectations.*

Expectations implied by this standard include those related to missing values,
or to types or ranges of input data, such as strictly binary values for
adjacency matrices.

- **NW2.4** *Network software which accept generic input structures should
  implement explicit parameters controlling the processing of missing values,
  ideally distinguishing `NA` or `NaN` values from `Inf` values (for example,
  through the use of `na.omit()` and related functions from the `stats`
  package). Network structures able to be specified in matrix form should
  permit and appropriately process missing values (even where appropriate
  processing is to error on missing values).*

- **NW2.5** *For matrix-based representations, documentation should explicitly
  describe and/or demonstrate whether sparse representations are used or
  permitted.*

#### Pre-processing of inputs

- **NW2.6** *Network Software should implement a single pre-processing routine
  to validate input data, and to appropriately transform it to a single uniform
  type to be passed to all subsequent data-processing functions.*

This function may even be applicable to software accepting class-based inputs,
in which a pre-processing routine should still be called to validate the
expected form and properties of any input. 

- **NW2.7** *This pre-processing function should maintain metadata attributes
  of input data which are relevant or important to core algorithms or return
  values. *

These metadata attributes include labels discussed in the following
sub-section, but may also include additional data such as numbers of vertices
and edges, timestamps, data sources, or any metadata necessary or useful for
appropriate interpretation of results.



#### Labels on input data

Network software often implements algorithms which identify or operate on
discrete sub-sets of a network, such as identifying discrete groups or clusters
of edges or vertices. In such cases, the membership of vertices or edges within
discrete groups is important, and is generally denoted by some kind of label.
The following standards apply to software which transfers attributes of input
data used to label vertices or edges on to output data.

- **NW2.8** *Network Software should transfer all relevant aspects of input
  data, notably including row and column names, and potentially information
  from other attributes (such as vertex or edge labels), to corresponding
  aspects of return objects.*
    - **NW2.8a** *Where otherwise relevant information is not transferred, this
      should be explicitly documented, or informative diagnostic messages
      should be issued.*

The following code provides an example of default behaviour in response to
input which has no properties or attributes to be transferred, beginning by
constructing a random binary adjacency matrix with pairwise connections set to
`TRUE` for adjacent vertices.

```{r bin-nb-mat, echo = TRUE}
n_verts <- 10L
edge_density <- 1 # Mean number edges per vertex
set.seed (1L)
nbs <- array (FALSE, dim = c (n_verts, n_verts))
nbs [sample (n_verts ^ 2, size = n_verts * edge_density)] <- TRUE
```

The following code then constructs an `igraph` graph from that adjacency
matrix, and enumerates the connected components of that graph.

```{r igraph-adj-no-labels, echo = TRUE}
library (igraph)
g <- graph_from_adjacency_matrix (nbs)
components (g)
```

The result of [the `igraph` components
function](https://igraph.org/r/html/latest/components.html) includes a
membership" vector with `n_verts` values, such that `membership[1]` gives the
group membership of the first vertex. Vertices in the above code were
unlabelled, and the "membership" values simply enumerate the groups from "1"
for the largest to, in this case, "3" for the smallest.

The following code demonstrates what happens when the input adjacency matrix is
labelled.

```{r igraph-adj-with-labels, echo = TRUE}
rownames (nbs) <- colnames (nbs) <- LETTERS [seq (nrow (nbs))]
g <- graph_from_adjacency_matrix (nbs)
components (g)
```

And the row and column names of the input adjacency matrix to labels of the
resultant output data, demonstrating that this aspect of) the `igraph` package
complies with standard **NW2.8**.

- **NW2.9** *Network software which uses attributes of input data such as row
  or column names to label output objects should assert that input data have
  non-default row or column names, and issue an informative message when these
  are not provided.*  

The first example above represents code which would comply with this standard,
because passing an *unlabelled* input yields a correspondingly unlabelled
output. If, however, the output from an unlabelled input was a *labelled*
membership vector, then compliance with this standard would require issuing a
message that default labels had been used.

- **NW2.10** *Network software for which input data does not generally include
  labels (such as array-like data with no row or column names) should provide
  an ability to specify labels.*

This standard may also be illustrated with a modified version of the code
above, starting by removing the row and column labels from the adjacency
matrix.

```{r igraph-labels-afterwards, echo = TRUE}
rownames (nbs) <- colnames (nbs) <- NULL
g <- graph_from_adjacency_matrix (nbs) # graph with no labels
nverts <- vcount (g) # igraph function to count vertices
vertex.attributes (g) <- list (name = LETTERS [seq (nverts)])
components (g)
```

The [`vertex.attributes <-` function of the `igraph`
package](https://igraph.org/r/html/latest/vertex_attr-set.html) enables
vertices to be labelled, and those labels are carried over to the output as in
the previous example. This `vertex.attributes` function would thus satisfy the
**NW2.10** standard.



### Data Structures

- **NW3.0** *Network software which at any stage uses sparse matrix
  representations (or use classes, which are sparse in structure ) should avoid
  converting to full matrix representations. In other words, sparse
  representations should be maintained throughout.* 

Where this standard can not be fulfilled, clear explanations should be given
for the necessity of converting from sparse to full representations.

- **NW3.1** *Where possible, adjacency matrices should be represented in sparse
  formats (such as from the `Matrix` package or  other sparse classes), and not
  as full matrices.*
  
Even where authors envision software to have a specific scope in which they
know matrices may be generally "small", the use of sparse representations is
the best way to ensure the software will readily extend to larger input sizes.

### Algorithms

- **NW4.0** *Software which represents networks as matrices, and which
  implements algorithms in C++, should generally use widely available libraries
  for matrix representation and manipulation.*

Examples of such libraries include [the
Armadillo](http://arma.sourceforge.net/) and
[Eigen](https://eigen.tuxfamily.org/) libraries, generally via R couplings such
as [the
`RcppArmadillo`](https://cran.r-project.org/web/packages/RcppArmadillo/index.html)
and [`RcppEigen`](https://dirk.eddelbuettel.com/code/rcpp.eigen.html) packages.

- **NW4.1** *Re-implementation of network-specific routines which exist in
  other commonly-used packages should explain, at least in code comments, the
  reasons for re-implementation.*
    - **NW4.1a** *Where the reason for re-implementation is an improved
      implementation, this must be demonstrated, at least in tests.*

Reasons for re-implementation may be as simple as wanting to avoid extra
package dependencies, or more complex reasons such as desire to implement a
parallel version of an algorithm.

#### Iteration in algorithms

Many network packages contain ways of "fitting" models to data, and such
fitting procedures are often iterative. The following standard applies to any
iterative procedures implemented within network software.

- **NW4.2** *Loops intended to run until convergence should always implement a
  parameter controlling maximum number of iterations.*

- **NW4.3** *Where iterative fitting procedures are used, these should either:*
    - **NW4.3a** *Include code comments which clearly explain why iteration always
    converges*; or
    - **NW4.3b** *Include code to detect (potential) non-convergence, and terminate
    iteration. Where termination conditions are not user-controlled, code
    comments should also explain and justify parameter values.*

- **NW4.4** *Where iterative fitting procedures are used, code should explicitly
  count numbers of iterations, with resultant values able to be returned
  directly from function calls (although not necessarily by default).*
    - **NW4.4a** *Routines which use an internally fixed number of maximal
      iterations should include a note justifying the value chosen.*

- **NW4.5** *Any exhaustive loops over multiple dimensions (> 1) of network matrices
  should generally be implemented in C/C++, or other efficient languages
  commonly placed in the `/src` sub-directory.*

The adjective "generally" in the previous standard leaves scope for this
standard not to be complied with, for example if a package has no other `/src`
code, and only implements one such loop. It should nevertheless be considered
bad practice to implement pairwise loops over all edges or vertices of a
network in R.


#### Network "grouping" Algorithms

The following standards apply to network software which discerns discrete
internal groups, such as clustering or dimensionality reduction algorithms.

- **NW4.6** *Network software should document how the ordering of groups is
  determined, and should explicitly state whether or not ordering is
  deterministic.*
    - **NW4.6a** *Software in which ordering or labels are not deterministic
      should document how users can set seeds or other parameters in order to
      obtain stable groups and/or labels.*

The code demonstrated above can be again used to illustrate compliance with
this standard for a deterministic grouping algorithm, starting with the same
binary adjacency matrix, `nbs`.

```{r igraph-group-labels}
rownames (nbs) <- colnames (nbs) <- LETTERS [seq (nrow (nbs))]
g <- graph_from_adjacency_matrix (nbs)
components (g)
```

The groups are labelled in the "membership" vector as discrete integers, with
"1" denoting the largest group; "2" the second largest; and so on. Adherence
with this standard would require documenting this labelling procedure.



### Return Objects and Generic Methods

- **NW5.0** *Return objects from network software should contain metadata on
  input networks, minimally including numbers of vertices and edges.*

- **NW5.1** *Network software may enable an ability to construct an empty
  return object (at no computational cost). This may be useful in controlling
  batch processing of computationally intensive network algorithms.*

- **NW5.2** *Network Software should implement default `print` methods for return objects.*

- **NW5.3** *The default print method should always ensure only a restricted
  portion of the full results are printed to the screen.*

- **NW5.4** *Network Software which returns some kind of models as outputs
  should also implement summary methods which should summarise the primary
  statistics used in generating the model (such as numbers of observations,
  parameters of methods applied). The summary method may also provide summary
  statistics from the resultant model.*

Network software which does not return model objects may of course also
implement `summary` methods complying with this standard.

- **NW5.5** *Network Software may also provide default `plot` methods for
  return objects.*

- **NW5.6** *Objects returned from Network Software which labels, categorise,
  or partitions data into discrete groups should include, or provide immediate
  access to, quantitative information on intra-group variances or equivalent,
  as well as on inter-group relationships where applicable.*

- **NW5.7** *The return object from Network Software should include, or
  otherwise enable immediate extraction of, all parameters used to control the
  algorithm used. *


#### Visualisation

- **NW5.8** *Network Software which includes plotting routines should document
  and demonstrate visualisation methods, such as through a dedicated vignette.
  Where possible, such demonstrations should also include generation of
  interactive visualisations.*

### Tests

Network Software should test the following properties and behaviours:

- **NW6.0** *Inappropriate types of input data are rejected with expected error messages.*

<!-- Do we need any specific guidance for the general convergence, stability, or performance tests?  The group ordering is one area that should be tested -->

#### Output Labelling

With regard to labelling of output data, tests for Network Software should:

- **NW6.1** *Demonstrate that labels placed on output data follow decreasing
  group sizes* (**NW4.6**).  <!-- See above -->

- **NW6.2** *Demonstrate that labels on input data are propagated to, or may be
  recovered from, output data* (**NW2.5**).


#### Algorithmic Scaling Tests

- **NW6.3** *Network software should include tests which demonstrate and confirm
  the scaling of algorithmic efficiency with network size* (**NW1.1**).
